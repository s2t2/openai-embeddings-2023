# -*- coding: utf-8 -*-
"""OpenAI Embeddings - Single Results File - v4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X8bFQ5sOKjLVOnQiXxMD07iyzqRRi4p_

## Load Data
"""

from pandas import read_csv

#request_url = "https://raw.githubusercontent.com/s2t2/openai-embeddings-2023/3214c695d462b1389f0d669ce865eef3a9963a55/results/reduced_classification/all_results.csv"
request_url = "https://raw.githubusercontent.com/s2t2/openai-embeddings-2023/one-csv/results/reduced_classification/all_results.csv"
df = read_csv(request_url)
#df["is_reduced"] = df["reducer_type"].notna()
df["reducer_type"].fillna(value="N/A", inplace=True)
df.head()

y_cols = list(df["y_col"].unique())
print("Y COLS:", y_cols)

print(df["y_col"].value_counts())

print(df["features"].value_counts())

df["roc_auc_score"].isna().sum()

"""## Colors

"""

BLUES = ["#82c8e2", "#a4d7ec"]
YELLOWS = ["#fffec3", "#f5eea5"]
REDS = ["#ff9288", "#ff625e"]
# https://www.heavy.ai/blog/12-color-palettes-for-telling-better-stories-with-your-data:
RETRO_METRO = ["#ea5545", "#f46a9b", "#ef9b20", "#edbf33", "#ede15b", "#bdcf32", "#87bc45", "#27aeef", "#b33dc6"]
RIVER_NIGHTS = ["#b30000", "#7c1158", "#4421af", "#1a53ff", "#0d88e6", "#00b7c7", "#5ad45a", "#8be04e", "#ebdc78"]
SPRING_PASTELS = ["#fd7f6f", "#7eb0d5", "#b2e061", "#bd7ebe", "#ffb55a", "#ffee65", "#beb9db", "#fdcce5", "#8bd3c7"]

PASTELS_MAP = {
    "LogisticRegression": SPRING_PASTELS[5], # 5
    "RandomForestClassifier": SPRING_PASTELS[0],  # 3
    "XGBClassifier": SPRING_PASTELS[1]
}
METRO_MAP = {
    "LogisticRegression": RETRO_METRO[3],
    "RandomForestClassifier":  RETRO_METRO[8],
    "XGBClassifier": SPRING_PASTELS[1] # RETRO_METRO[7]
}
#COLORS_MAP = {"model_type": {
#    "LogisticRegression": SPRING_PASTELS[5], # RETRO_METRO[3],
#    "RandomForestClassifier": SPRING_PASTELS[3], #RETRO_METRO[8],
#    "XGBClassifier": SPRING_PASTELS[1] # RETRO_METRO[7]
#}}

"""## Analysis

### Best Results

What's the best result for each y / target col?
"""

metric_col = "roc_auc_score" #@param ["roc_auc_score", "accuracy", "f1_macro", "f1_weighted"]
print(metric_col)

"""#### ... for all datasets?

It happens that all the best results are produced by using the full 1536 embeddings as features:
"""

#df.groupby("y_col")[metric_col].max().sort_values(ascending=False)

best_rows = df.groupby("y_col")[metric_col].idxmax()
best = df.loc[best_rows].copy()
best[["features", "y_col", "model_type", metric_col]].sort_values(by=metric_col, ascending=False)

import plotly.express as px

chart_df = best.sort_values(by=metric_col, ascending=True)
px.bar(chart_df, orientation="h", x=metric_col, y="y_col",
       title="Best results for each classification target",
       hover_data=["model_type", "features", "best_params"],
       text= metric_col # "features" #"model_type" #metric_col, # "model_type",
    )

"""#### ... for just the reduced features?"""

reduced_df = df[df["reducer_type"] != "N/A"].copy()
reduced_df["features"].value_counts()

#reduced_df.groupby("y_col")[metric_col].max().sort_values(ascending=False)

best_rows_reduced = reduced_df.groupby("y_col")[metric_col].idxmax()
best_reduced = reduced_df.loc[best_rows_reduced]
best_reduced[["features", "y_col", "model_type", metric_col]].sort_values(by=metric_col, ascending=False)

import plotly.express as px

chart_df = best_reduced.sort_values(by=metric_col, ascending=True)
fig = px.bar(chart_df, orientation="h", x=metric_col, y="y_col",
       title="Best results for each classification target (reduced features)",
       hover_data=["model_type", "features", "best_params"],
       text="features", # metric_col, # "model_type",
       #color="model_type", color_discrete_map=PASTELS_MAP
    )
# for some reason, coloring messes up sort order, so re-sort:
fig.update_layout(yaxis={'categoryorder': 'total ascending'})
fig.show()

"""### All Results

#### Bar Chart Maker
"""

import plotly.express as px

def chart_maker(y_col="is_bot", metric_col="roc_auc_score", fig_show=False, height=500, color_map=PASTELS_MAP):
    chart_df = df[df["y_col"] == y_col].copy()
    #print(chart_df[["features", "model_type", metric_col]].head())

    fig = px.bar(chart_df, y=metric_col, facet_col="features", x="model_type",
        height=height, title=f"Classification Results (y_col='{y_col}')",
        text=metric_col,
        labels={"index": "", "model_type":""},
        color="model_type", color_discrete_map=color_map
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.replace("features=", "")))

    fig.update_xaxes(showticklabels=False)

    if fig_show:
        fig.show()

    return fig

chart_maker(y_col="is_bot")

chart_maker(y_col="opinion_community")

chart_maker(y_col="fourway_label")

chart_maker(y_col="is_bom_astroturf")

chart_maker(y_col="is_toxic")

chart_maker(y_col="is_factual")

"""#### Dumbbell Chart Maker

If you want the best scores on top, we reverse the y col order here, and use that in a few places to make the chart.
"""

df_sorted = df.sort_values(by=[metric_col], ascending=False)
y_cols_reversed = list(reversed(df_sorted["y_col"].unique()))
y_cols_reversed

metric_col = "roc_auc_score"
model_a = "LogisticRegression"
model_b = "RandomForestClassifier"
model_c = "XGBClassifier"

line_x, line_y, series_a, series_b, series_c = [], [], [], [], []

for y_col in y_cols_reversed:
    val_a = df.loc[(df["reducer_type"] == "N/A") & (df["y_col"] == y_col) & (df["model_type"] == model_a)][metric_col].values[0]
    val_b = df.loc[(df["reducer_type"] == "N/A") & (df["y_col"] == y_col) & (df["model_type"] == model_b)][metric_col].values[0]
    val_c = df.loc[(df["reducer_type"] == "N/A") & (df["y_col"] == y_col) & (df["model_type"] == model_c)][metric_col].values[0]

    series_a.extend([val_a])
    series_b.extend([val_b])
    series_c.extend([val_c])
    line_x.extend([val_a, val_b, val_c, None]) # # the None is supposedly a magic trick to not connect the lines
    line_y.extend([y_col, y_col, y_col, None]) # the None is supposedly a magic trick to not connect the lines


print("-------------")
# four points per row:
print("LINE X:", line_x[0:8])
print("LINE Y:", line_y[0:8])
print("-------------")
# one point per row:
print("YEAR A:", series_a[0:8])
print("YEAR B:", series_b[0:8])
print("YEAR C:", series_c[0:8])
print("-------------")
print(len(line_x), len(line_y), len(series_a), len(series_b), len(series_c))

import plotly.graph_objects as go


# line from lowest to highest (will pass through middle)
line_xy = go.Scatter(x=line_x, y=line_y,
                    mode="lines", marker=dict(color="grey"), showlegend=False,
)

# point for series a
point_a = go.Scatter(x=series_a, y=y_cols_reversed, name=model_a,
                    mode="markers",  marker=dict(color=PASTELS_MAP[model_a],size=10),
)

# point for series b
point_b = go.Scatter(x=series_b, y=y_cols_reversed, name=model_b,
                    mode="markers", marker=dict(color=PASTELS_MAP[model_b],size=10),
)

# point for series c
point_c = go.Scatter(x=series_c, y=y_cols_reversed, name=model_c,
            mode="markers", marker=dict(color=PASTELS_MAP[model_c],size=10)
)

fig = go.Figure(data=[line_xy, point_a, point_b, point_c])
title = "Classification Results (original embeddings)"
fig.update_layout(title=title, height=500, legend_itemclick=False,
                  #xaxis=dict(type='log')
                  )
fig.show()